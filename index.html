<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Golden Ink</title>
    <!-- TensorFlow.js and COCO-SSD for subject detection -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #1a1a2e;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            padding-bottom: 30px;
            touch-action: pan-y;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .header {
            color: #d4a44a;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 18px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pencil-status {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 12px;
            background: #333;
            color: #888;
        }

        .pencil-status.active {
            background: #2a5a2a;
            color: #6f6;
        }

        .canvas-container {
            position: relative;
            background: #2a2a3e;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            width: 800px;
            height: 480px;
            max-width: calc(100vw - 20px);
        }

        canvas {
            display: block;
            touch-action: none;
            position: absolute;
            top: 0;
            left: 0;
        }

        #bgCanvas { z-index: 0; }
        #glowCanvas { z-index: 1; }
        #doubleCanvas { z-index: 2; }
        #drawCanvas { z-index: 3; opacity: 0; }
        #effectCanvas { z-index: 4; pointer-events: none; }

        .controls {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            background: #d4a44a;
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            touch-action: manipulation;
        }

        button:active {
            background: #b8903a;
            transform: scale(0.98);
        }

        button.secondary {
            background: #444;
            color: #fff;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pattern-designer {
            margin-top: 20px;
            max-width: calc(100vw - 20px);
        }

        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            color: #d4a44a;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 14px;
        }

        .pattern-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .pattern-controls label {
            color: #888;
            font-size: 12px;
        }

        .pattern-controls input[type="range"] {
            width: 80px;
        }

        .pattern-container {
            background: #2a2a3e;
            border-radius: 8px;
            overflow: hidden;
        }

        #patternCanvas {
            display: block;
            width: 100%;
            cursor: crosshair;
            position: relative;
            top: auto;
            left: auto;
        }

        .pattern-hint {
            color: #666;
            font-size: 11px;
            margin-top: 6px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        /* Background image controls */
        .bg-controls {
            margin-top: 12px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .model-status {
            font-size: 11px;
            color: #888;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .model-status.ready {
            color: #6f6;
        }

        .model-status.loading {
            color: #fa0;
        }

        .signing-area-indicator {
            position: absolute;
            border: 2px dashed rgba(212, 164, 74, 0.5);
            border-radius: 8px;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        .signing-area-indicator.visible {
            display: block;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { border-color: rgba(212, 164, 74, 0.3); }
            50% { border-color: rgba(212, 164, 74, 0.7); }
        }

        .signing-label {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 26, 46, 0.8);
            color: #d4a44a;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
    </style>
</head>
<body>
    <div class="header">
        <span>Golden Ink</span>
        <span class="pencil-status" id="pencilStatus">No Pencil</span>
        <span style="font-size: 10px; color: #666;">v2.9</span>
    </div>

    <div class="canvas-container" id="container">
        <canvas id="bgCanvas"></canvas>
        <canvas id="glowCanvas"></canvas>
        <canvas id="doubleCanvas"></canvas>
        <canvas id="drawCanvas"></canvas>
        <canvas id="effectCanvas"></canvas>
        <div class="signing-area-indicator" id="signingArea">
            <span class="signing-label">Sign here</span>
        </div>
    </div>

    <!-- Background Image Controls -->
    <div class="bg-controls">
        <div class="file-input-wrapper">
            <button id="uploadBgBtn">Upload Background</button>
            <input type="file" id="bgImageInput" accept="image/*">
        </div>
        <button id="subjectLeftBtn" class="secondary" style="padding: 8px 16px;">Subject Left</button>
        <button id="subjectRightBtn" class="secondary" style="padding: 8px 16px;">Subject Right</button>
        <button id="clearBgBtn" class="secondary" style="padding: 8px 16px;">Clear BG</button>
        <span class="model-status" id="modelStatus">Loading AI model...</span>
    </div>

    <!-- Background Effect Controls -->
    <div class="bg-controls" style="margin-top: 8px;">
        <span style="color: #888; font-size: 12px;">Background:</span>
        <button id="bgModeNormal" class="secondary" style="padding: 8px 12px;">Normal</button>
        <button id="bgModeBlur" class="secondary" style="padding: 8px 12px;">Blur</button>
        <button id="bgModeFade" class="secondary" style="padding: 8px 12px;">Fade</button>
        <button id="bgModeRemove" class="secondary" style="padding: 8px 12px;">Remove</button>
        <span class="model-status" id="bgEffectStatus"></span>
    </div>

    <!-- Background Removal Fine-tuning Controls -->
    <div id="removalControls" class="bg-controls" style="margin-top: 8px; display: none; flex-wrap: wrap; gap: 12px;">
        <label style="color: #888; font-size: 11px; display: flex; align-items: center; gap: 4px;">
            Threshold: <input type="range" id="maskThreshold" min="50" max="250" value="180" style="width: 60px;">
            <span id="thresholdValue" style="min-width: 24px;">180</span>
        </label>
        <label style="color: #888; font-size: 11px; display: flex; align-items: center; gap: 4px;">
            Edge: <input type="range" id="maskExpand" min="-20" max="20" value="0" style="width: 60px;">
            <span id="expandValue" style="min-width: 24px;">0</span>
        </label>
        <label style="color: #888; font-size: 11px; display: flex; align-items: center; gap: 4px;">
            Feather: <input type="range" id="maskFeather" min="0" max="10" value="0" style="width: 60px;">
            <span id="featherValue" style="min-width: 24px;">0</span>
        </label>
        <button id="reprocessBtn" class="secondary" style="padding: 6px 12px; font-size: 11px;">Reprocess</button>
        <button id="drawOutlineBtn" class="secondary" style="padding: 6px 12px; font-size: 11px;">Draw Outline</button>
        <button id="clearOutlineBtn" class="secondary" style="padding: 6px 12px; font-size: 11px; display: none;">Clear Outline</button>
        <button id="cleanupBrushBtn" class="secondary" style="padding: 6px 12px; font-size: 11px;">Cleanup Brush</button>
    </div>

    <!-- Cleanup Brush Mode Controls -->
    <div id="cleanupControls" class="bg-controls" style="margin-top: 8px; display: none; gap: 12px;">
        <span style="color: #888; font-size: 11px;">Brush Mode:</span>
        <button id="brushErase" class="secondary" style="padding: 6px 12px; font-size: 11px; background: #a33;">Erase</button>
        <button id="brushRestore" class="secondary" style="padding: 6px 12px; font-size: 11px;">Restore</button>
        <label style="color: #888; font-size: 11px; display: flex; align-items: center; gap: 4px;">
            Size: <input type="range" id="brushSize" min="5" max="50" value="20" style="width: 60px;">
            <span id="brushSizeValue" style="min-width: 24px;">20</span>
        </label>
        <button id="doneCleanupBtn" class="secondary" style="padding: 6px 12px; font-size: 11px;">Done</button>
    </div>

    <div class="controls">
        <button id="clearBtn">Clear Drawing</button>
        <button id="undoBtn" class="secondary">Undo</button>
        <button id="fillBtn" class="secondary">Fill Canvas</button>
        <button id="playPauseBtn" class="secondary">Pause</button>
        <button id="playRecordingBtn" class="secondary">Replay</button>
    </div>

    <div class="controls" style="margin-top: 8px;">
        <label style="color: #888; font-size: 12px; display: flex; align-items: center; gap: 6px;">
            Direction:
            <button id="directionBtn" class="secondary" style="padding: 8px 16px;">â†’ Right</button>
        </label>
        <label style="color: #888; font-size: 12px; display: flex; align-items: center; gap: 6px;">
            Speed: <input type="range" id="speedSlider" min="1" max="10" value="2" style="width: 80px;">
            <span id="speedValue">2</span>
        </label>
    </div>

    <div class="pattern-designer">
        <div class="pattern-header">
            <span>Pattern Designer</span>
            <div class="pattern-controls">
                <label>Brush: <input type="range" id="patternBrushSize" min="10" max="100" value="40"></label>
                <button id="resetPatternBtn" class="secondary" style="padding:8px 12px;">Reset Gold</button>
            </div>
        </div>
        <div class="pattern-container" id="patternContainer">
            <canvas id="patternCanvas"></canvas>
        </div>
        <div class="pattern-hint">Paint cream/white highlights on gold background - this pattern will animate over your handwriting</div>
    </div>

    <script>
        // =====================================================================
        // CONFIGURATION - Locked in chisel calligraphy settings
        // =====================================================================
        const config = {
            // Pressure settings
            pressureEnabled: true,
            pressureMultiplier: 1.2,
            pressureCurve: 0.8,

            // Width settings
            minWidth: 2,
            maxWidth: 28,  // Heavier downstrokes

            // Smoothing
            smoothingEnabled: true,
            smoothingFactor: 0.6,  // Higher = smoother strokes

            // Velocity-based width
            velocityEnabled: true,
            velocityFactor: 0.3,

            // Palm rejection
            palmRejection: true,

            // Chisel mode - DISABLED for smoother strokes
            chiselMode: false,
            chiselRatio: 4,
            chiselAngle: 45,

            // Stabilizer
            stabilizerEnabled: true,
            stabilizerStrength: 0.5,  // Higher = more stable strokes

            // Direction-based width (calligraphy) - downstrokes are thicker
            directionWidthEnabled: true,
            directionWidthMin: 0.02,  // Non-downstrokes are 2% width - much thinner

            // Effects
            doubleStrokeEnabled: true,
            doubleStrokeOffset: 2,      // Pixel offset for doubled stroke
            doubleStrokeColor: '#CC6600', // Darker orange shadow

            // Main stroke color (white/cream)
            strokeColor: '#FFFFFF', // White strokes

            // Radial glow behind text (like a spotlight/energy source)
            radialGlowEnabled: true,
        };

        // =====================================================================
        // CANVAS SETUP
        // =====================================================================
        const container = document.getElementById('container');
        const bgCanvas = document.getElementById('bgCanvas');
        const glowCanvas = document.getElementById('glowCanvas');
        const doubleCanvas = document.getElementById('doubleCanvas');
        const drawCanvas = document.getElementById('drawCanvas');
        const effectCanvas = document.getElementById('effectCanvas');

        const bgCtx = bgCanvas.getContext('2d');
        const glowCtx = glowCanvas.getContext('2d');
        const doubleCtx = doubleCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        const effectCtx = effectCanvas.getContext('2d');

        let canvasWidth, canvasHeight;

        // Background image state
        let backgroundImage = null;
        let backgroundImageOriginal = null;  // Keep original for reprocessing
        let backgroundImageRemoved = null;   // Cached removed background version
        let detectedSubject = null;
        let subjectPosition = 'left';  // 'left' or 'right'
        let autoPositionSubject = true;  // Auto-detect optimal side
        let cocoModel = null;
        let signingAreaBounds = null;
        let bgMode = 'normal';  // 'normal', 'blur', 'fade', 'remove'
        let isProcessingBg = false;

        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;

            const maxWidth = Math.min(800, window.innerWidth - 20);
            const maxHeight = Math.min(480, window.innerHeight - 150);

            let width = maxWidth;
            let height = width * 0.6;

            if (height > maxHeight) {
                height = maxHeight;
                width = height / 0.6;
            }

            canvasWidth = width;
            canvasHeight = height;

            container.style.width = width + 'px';
            container.style.height = height + 'px';

            [bgCanvas, glowCanvas, doubleCanvas, drawCanvas, effectCanvas].forEach(canvas => {
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';

                const ctx = canvas.getContext('2d');
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
            });

            // Set up drawing contexts
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';
            drawCtx.strokeStyle = '#FFFFFF';

            doubleCtx.lineCap = 'round';
            doubleCtx.lineJoin = 'round';
            doubleCtx.strokeStyle = config.doubleStrokeColor;

            glowCtx.lineCap = 'round';
            glowCtx.lineJoin = 'round';

            // Draw background
            drawBackground();
        }

        function drawBackground() {
            if (backgroundImage) {
                drawBackgroundWithSubject();
            } else {
                bgCtx.fillStyle = '#3a3a4e';
                bgCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                hideSigningArea();
            }
        }

        setupCanvas();
        window.addEventListener('resize', () => {
            setupCanvas();
            if (backgroundImage) {
                drawBackgroundWithSubject();
            }
        });

        // =====================================================================
        // SUBJECT DETECTION (TensorFlow.js COCO-SSD)
        // =====================================================================
        async function loadModel() {
            const statusEl = document.getElementById('modelStatus');
            statusEl.textContent = 'Loading AI model...';
            statusEl.className = 'model-status loading';

            try {
                cocoModel = await cocoSsd.load();
                statusEl.textContent = 'AI Ready';
                statusEl.className = 'model-status ready';
                console.log('COCO-SSD model loaded');
            } catch (err) {
                console.error('Failed to load model:', err);
                statusEl.textContent = 'AI unavailable';
                statusEl.className = 'model-status';
            }
        }

        async function detectSubject(img) {
            if (!cocoModel) {
                console.log('Model not loaded, using center detection');
                return detectSubjectFallback(img);
            }

            try {
                const predictions = await cocoModel.detect(img);
                console.log('Detected objects:', predictions);

                // Filter for significant detections (people, animals, main objects)
                const priorityClasses = ['person', 'dog', 'cat', 'horse', 'bird', 'car', 'motorcycle', 'bicycle'];
                const significantPredictions = predictions.filter(p =>
                    p.score > 0.5 && (priorityClasses.includes(p.class) || p.score > 0.7)
                );

                if (significantPredictions.length === 0) {
                    console.log('No significant subjects detected, using fallback');
                    return detectSubjectFallback(img);
                }

                // Find the largest/most prominent subject
                let bestSubject = significantPredictions[0];
                let bestArea = bestSubject.bbox[2] * bestSubject.bbox[3];

                for (const pred of significantPredictions) {
                    const area = pred.bbox[2] * pred.bbox[3];
                    // Prioritize people
                    if (pred.class === 'person' && bestSubject.class !== 'person') {
                        bestSubject = pred;
                        bestArea = area;
                    } else if (area > bestArea && (pred.class === bestSubject.class || bestSubject.class !== 'person')) {
                        bestSubject = pred;
                        bestArea = area;
                    }
                }

                return {
                    x: bestSubject.bbox[0],
                    y: bestSubject.bbox[1],
                    width: bestSubject.bbox[2],
                    height: bestSubject.bbox[3],
                    class: bestSubject.class,
                    score: bestSubject.score
                };
            } catch (err) {
                console.error('Detection failed:', err);
                return detectSubjectFallback(img);
            }
        }

        function detectSubjectFallback(img) {
            // Simple fallback: assume subject is in the center-ish area
            // This uses edge detection heuristics
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            tempCtx.drawImage(img, 0, 0);

            // Analyze image to find the "busy" region (likely the subject)
            const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;

            // Calculate variance in different regions
            const gridSize = 4;
            const cellWidth = img.width / gridSize;
            const cellHeight = img.height / gridSize;
            let maxVariance = 0;
            let maxVarianceX = img.width / 2;
            let maxVarianceY = img.height / 2;

            for (let gy = 0; gy < gridSize; gy++) {
                for (let gx = 0; gx < gridSize; gx++) {
                    let sum = 0, sumSq = 0, count = 0;

                    for (let y = Math.floor(gy * cellHeight); y < Math.floor((gy + 1) * cellHeight); y += 4) {
                        for (let x = Math.floor(gx * cellWidth); x < Math.floor((gx + 1) * cellWidth); x += 4) {
                            const idx = (y * img.width + x) * 4;
                            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                            sum += brightness;
                            sumSq += brightness * brightness;
                            count++;
                        }
                    }

                    const mean = sum / count;
                    const variance = (sumSq / count) - (mean * mean);

                    if (variance > maxVariance) {
                        maxVariance = variance;
                        maxVarianceX = (gx + 0.5) * cellWidth;
                        maxVarianceY = (gy + 0.5) * cellHeight;
                    }
                }
            }

            // Estimate subject bounds around the high-variance area
            const subjectWidth = img.width * 0.5;
            const subjectHeight = img.height * 0.8;

            return {
                x: Math.max(0, maxVarianceX - subjectWidth / 2),
                y: Math.max(0, maxVarianceY - subjectHeight / 2),
                width: subjectWidth,
                height: subjectHeight,
                class: 'unknown',
                score: 0.5
            };
        }

        // =====================================================================
        // BACKGROUND IMAGE HANDLING
        // =====================================================================
        function drawBackgroundWithSubject() {
            if (!backgroundImage) return;

            const img = backgroundImage;
            const imgAspect = img.width / img.height;
            const canvasAspect = canvasWidth / canvasHeight;

            // Clear background
            bgCtx.fillStyle = '#3a3a4e';
            bgCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (!detectedSubject) {
                // No subject detected, just fit the image
                let drawWidth, drawHeight, drawX, drawY;
                if (imgAspect > canvasAspect) {
                    drawHeight = canvasHeight;
                    drawWidth = drawHeight * imgAspect;
                    drawX = (canvasWidth - drawWidth) / 2;
                    drawY = 0;
                } else {
                    drawWidth = canvasWidth;
                    drawHeight = drawWidth / imgAspect;
                    drawX = 0;
                    drawY = (canvasHeight - drawHeight) / 2;
                }
                bgCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                hideSigningArea();
                return;
            }

            const subject = detectedSubject;
            const subjectCenterX = subject.x + subject.width / 2;
            const subjectCenterY = subject.y + subject.height / 2;

            // Auto-detect optimal side: if subject is right of center, put them on right
            // This crops out the "dead space" on the opposite side
            if (autoPositionSubject) {
                const imgCenterX = img.width / 2;
                subjectPosition = subjectCenterX > imgCenterX ? 'right' : 'left';
                updatePositionButtons();
            }

            // Focus on upper body - use top 35% of subject bounding box
            const subjectFocusY = subject.y + subject.height * 0.35;

            // Calculate scale: zoom in so subject's upper body fills the frame nicely
            // Target: subject width should be about 40-50% of their side (which is 25% of canvas)
            // So subject width = ~10-12% of total canvas, but we want them prominent
            const targetSubjectWidth = canvasWidth * 0.30;  // Subject takes 30% of canvas width
            const scaleByWidth = targetSubjectWidth / subject.width;

            // Also consider height - make sure upper body fills vertically
            const targetSubjectHeight = canvasHeight * 0.8;  // Upper body should be ~80% of height
            const scaleByHeight = targetSubjectHeight / (subject.height * 0.6);  // Upper 60% of body

            // Use the larger scale to zoom in more
            const subjectScale = Math.max(scaleByWidth, scaleByHeight);

            // Minimum scale: at least fill the canvas
            const coverScale = Math.max(canvasWidth / img.width, canvasHeight / img.height);
            const scale = Math.max(subjectScale, coverScale);

            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const scaledSubjectCenterX = subjectCenterX * scale;
            const scaledSubjectWidth = subject.width * scale;

            // Position subject at edge of their 25% zone
            // For right side: subject center at 87.5% of canvas (middle of right 25%)
            // For left side: subject center at 12.5% of canvas (middle of left 25%)
            let targetX;
            if (subjectPosition === 'right') {
                // Put subject on right - their center should be at ~85% of canvas
                targetX = canvasWidth * 0.85;
            } else {
                // Put subject on left - their center should be at ~15% of canvas
                targetX = canvasWidth * 0.15;
            }

            let offsetX = targetX - scaledSubjectCenterX;

            // For right positioning: we want to crop the LEFT side of the image
            // So offsetX should be negative (shift image left)
            // For left positioning: we want to crop the RIGHT side
            // So offsetX should be positive or zero

            // Only clamp to prevent showing empty canvas on the subject's side
            if (subjectPosition === 'right') {
                // Don't show empty space on right edge
                offsetX = Math.max(canvasWidth - scaledWidth, offsetX);
                // Allow cropping on left (negative offset OK, but not too much)
                offsetX = Math.min(0, offsetX);
            } else {
                // Don't show empty space on left edge
                offsetX = Math.min(0, offsetX);
                // Allow cropping on right
                offsetX = Math.max(canvasWidth - scaledWidth, offsetX);
            }

            // Position vertically - PRIORITY: preserve head, crop from bottom
            const scaledSubjectTop = subject.y * scale;  // Top of subject's head
            const headPadding = canvasHeight * 0.05;  // 5% padding above head

            // Position head near top with padding - this allows legs to be cropped
            let offsetY = headPadding - scaledSubjectTop;

            // Don't show empty space at top of canvas
            offsetY = Math.min(0, offsetY);

            // Only apply bottom constraint if it wouldn't crop the head
            const bottomConstraint = canvasHeight - scaledHeight;
            // If bottom constraint would push head off screen, ignore it (crop bottom instead)
            const headPositionWithBottomConstraint = scaledSubjectTop + bottomConstraint;
            if (headPositionWithBottomConstraint >= headPadding) {
                // Safe to apply bottom constraint - head will still be visible
                offsetY = Math.max(bottomConstraint, offsetY);
            }
            // Otherwise, let bottom be cropped/empty to preserve the head

            // Draw based on background mode
            if (bgMode === 'remove' && backgroundImageRemoved) {
                // Use the pre-processed removed background image
                bgCtx.drawImage(backgroundImageRemoved, offsetX, offsetY, scaledWidth, scaledHeight);
            } else if (bgMode === 'blur') {
                // Draw blurred background first
                bgCtx.filter = 'blur(8px)';
                bgCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                bgCtx.filter = 'none';

                // Draw sharp subject on top using a mask
                if (detectedSubject) {
                    const sx = subject.x * scale + offsetX;
                    const sy = subject.y * scale + offsetY;
                    const sw = subject.width * scale;
                    const sh = subject.height * scale;

                    // Expand the subject area slightly for better coverage
                    const padding = sw * 0.15;
                    bgCtx.save();
                    bgCtx.beginPath();
                    bgCtx.ellipse(sx + sw/2, sy + sh/2, sw/2 + padding, sh/2 + padding, 0, 0, Math.PI * 2);
                    bgCtx.clip();
                    bgCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                    bgCtx.restore();
                }
            } else if (bgMode === 'fade') {
                // Draw faded background
                bgCtx.globalAlpha = 0.3;
                bgCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                bgCtx.globalAlpha = 1.0;

                // Draw subject area at full opacity
                if (detectedSubject) {
                    const sx = subject.x * scale + offsetX;
                    const sy = subject.y * scale + offsetY;
                    const sw = subject.width * scale;
                    const sh = subject.height * scale;

                    const padding = sw * 0.15;
                    bgCtx.save();
                    bgCtx.beginPath();
                    bgCtx.ellipse(sx + sw/2, sy + sh/2, sw/2 + padding, sh/2 + padding, 0, 0, Math.PI * 2);
                    bgCtx.clip();
                    bgCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                    bgCtx.restore();
                }
            } else {
                // Normal mode
                bgCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
            }

            // Calculate and show signing area (opposite 75% of canvas)
            const signingPadding = 20;
            if (subjectPosition === 'left') {
                signingAreaBounds = {
                    x: canvasWidth * 0.25 + signingPadding,
                    y: signingPadding,
                    width: canvasWidth * 0.75 - signingPadding * 2,
                    height: canvasHeight - signingPadding * 2
                };
            } else {
                signingAreaBounds = {
                    x: signingPadding,
                    y: signingPadding,
                    width: canvasWidth * 0.75 - signingPadding * 2,
                    height: canvasHeight - signingPadding * 2
                };
            }

            showSigningArea(signingAreaBounds);
        }

        function updatePositionButtons() {
            if (subjectPosition === 'left') {
                document.getElementById('subjectLeftBtn').style.background = '#d4a44a';
                document.getElementById('subjectLeftBtn').style.color = '#1a1a2e';
                document.getElementById('subjectRightBtn').style.background = '#444';
                document.getElementById('subjectRightBtn').style.color = '#fff';
            } else {
                document.getElementById('subjectRightBtn').style.background = '#d4a44a';
                document.getElementById('subjectRightBtn').style.color = '#1a1a2e';
                document.getElementById('subjectLeftBtn').style.background = '#444';
                document.getElementById('subjectLeftBtn').style.color = '#fff';
            }
        }

        function showSigningArea(bounds) {
            const indicator = document.getElementById('signingArea');
            indicator.style.left = bounds.x + 'px';
            indicator.style.top = bounds.y + 'px';
            indicator.style.width = bounds.width + 'px';
            indicator.style.height = bounds.height + 'px';
            indicator.classList.add('visible');

            // Hide after 3 seconds
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 3000);
        }

        function hideSigningArea() {
            const indicator = document.getElementById('signingArea');
            indicator.classList.remove('visible');
            signingAreaBounds = null;
        }

        async function handleBackgroundImage(file) {
            const img = new Image();
            img.onload = async () => {
                backgroundImage = img;
                backgroundImageOriginal = img;  // Save original for reprocessing
                backgroundImageRemoved = null;  // Reset cached removed version

                // Detect subject
                const statusEl = document.getElementById('modelStatus');
                statusEl.textContent = 'Detecting subject...';
                statusEl.className = 'model-status loading';

                detectedSubject = await detectSubject(img);

                if (detectedSubject) {
                    statusEl.textContent = `Found: ${detectedSubject.class} (${Math.round(detectedSubject.score * 100)}%)`;
                } else {
                    statusEl.textContent = 'No subject found';
                }
                statusEl.className = 'model-status ready';

                console.log('Detected subject:', detectedSubject);
                drawBackgroundWithSubject();

                // If remove mode is active, start background removal
                if (bgMode === 'remove') {
                    processBackgroundRemoval();
                }
            };
            img.src = URL.createObjectURL(file);
        }

        // Background image controls
        document.getElementById('bgImageInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleBackgroundImage(file);
            }
        });

        document.getElementById('subjectLeftBtn').addEventListener('click', () => {
            autoPositionSubject = false;  // Manual override
            subjectPosition = 'left';
            updatePositionButtons();
            if (backgroundImage) {
                drawBackgroundWithSubject();
            }
        });

        document.getElementById('subjectRightBtn').addEventListener('click', () => {
            autoPositionSubject = false;  // Manual override
            subjectPosition = 'right';
            updatePositionButtons();
            if (backgroundImage) {
                drawBackgroundWithSubject();
            }
        });

        document.getElementById('clearBgBtn').addEventListener('click', () => {
            backgroundImage = null;
            backgroundImageOriginal = null;
            backgroundImageRemoved = null;
            detectedSubject = null;
            autoPositionSubject = true;  // Reset to auto
            bgMode = 'normal';
            updateBgModeButtons();
            hideSigningArea();
            drawBackground();
            document.getElementById('modelStatus').textContent = 'AI Ready';
            document.getElementById('modelStatus').className = 'model-status ready';
            document.getElementById('bgEffectStatus').textContent = '';
        });

        // Background mode buttons
        function updateBgModeButtons() {
            ['Normal', 'Blur', 'Fade', 'Remove'].forEach(mode => {
                const btn = document.getElementById('bgMode' + mode);
                if (mode.toLowerCase() === bgMode) {
                    btn.style.background = '#d4a44a';
                    btn.style.color = '#1a1a2e';
                } else {
                    btn.style.background = '#444';
                    btn.style.color = '#fff';
                }
            });
            // Show/hide removal controls
            const removalControls = document.getElementById('removalControls');
            if (removalControls) {
                removalControls.style.display = bgMode === 'remove' ? 'flex' : 'none';
            }
        }

        // Mask processing settings
        let maskThreshold = 180;
        let maskExpand = 0;
        let maskFeather = 0;
        let userOutline = null;  // User-drawn outline for subject selection
        let cleanupMode = null;  // 'erase' or 'restore'
        let brushSize = 20;
        let segmentationMaskCanvas = null;  // Store raw segmentation for reprocessing
        let isCleaningUp = false;  // Currently painting with cleanup brush

        // MediaPipe Selfie Segmentation - fast, lightweight, designed for real-time
        let selfieSegmentation = null;

        async function loadMediaPipeSegmentation() {
            if (selfieSegmentation) return selfieSegmentation;

            // Load MediaPipe scripts dynamically
            const loadScript = (src) => new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });

            // Load MediaPipe Selfie Segmentation
            await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js');

            selfieSegmentation = new SelfieSegmentation({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
            });

            selfieSegmentation.setOptions({
                modelSelection: 1,  // 0 = general, 1 = landscape (faster)
                selfieMode: false,
            });

            return selfieSegmentation;
        }

        // Cleanup brush for manual mask editing
        function applyCleanupBrush(e) {
            if (!backgroundImageRemoved) return;

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = backgroundImageOriginal.width / rect.width;
            const scaleY = backgroundImageOriginal.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Create a temp canvas to modify the removed background image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = backgroundImageOriginal.width;
            tempCanvas.height = backgroundImageOriginal.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw current removed background
            tempCtx.drawImage(backgroundImageRemoved, 0, 0);

            if (cleanupMode === 'erase') {
                // Erase: make pixels transparent
                tempCtx.globalCompositeOperation = 'destination-out';
                tempCtx.beginPath();
                tempCtx.arc(x, y, brushSize * scaleX, 0, Math.PI * 2);
                tempCtx.fill();
            } else if (cleanupMode === 'restore') {
                // Restore: bring back pixels from original
                tempCtx.globalCompositeOperation = 'source-over';
                // First clip to circle
                tempCtx.save();
                tempCtx.beginPath();
                tempCtx.arc(x, y, brushSize * scaleX, 0, Math.PI * 2);
                tempCtx.clip();
                // Draw original image in clipped area
                tempCtx.drawImage(backgroundImageOriginal, 0, 0);
                tempCtx.restore();
            }

            // Update the removed background image
            const resultUrl = tempCanvas.toDataURL('image/png');
            const newImg = new Image();
            newImg.onload = () => {
                backgroundImageRemoved = newImg;
                drawBackgroundWithSubject();
            };
            newImg.src = resultUrl;
        }

        async function processBackgroundRemoval() {
            if (!backgroundImageOriginal || isProcessingBg) return;
            if (backgroundImageRemoved) {
                // Already processed
                drawBackgroundWithSubject();
                return;
            }

            isProcessingBg = true;
            const statusEl = document.getElementById('bgEffectStatus');
            statusEl.textContent = 'Loading segmentation...';
            statusEl.className = 'model-status loading';

            try {
                const segmenter = await loadMediaPipeSegmentation();
                statusEl.textContent = 'Processing...';

                // Create a promise that resolves when segmentation is complete
                const segmentationResult = await new Promise((resolve, reject) => {
                    segmenter.onResults((results) => {
                        resolve(results);
                    });

                    // Send the image to the segmenter
                    segmenter.send({ image: backgroundImageOriginal }).catch(reject);
                });

                // Create mask canvas from segmentation
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = backgroundImageOriginal.width;
                maskCanvas.height = backgroundImageOriginal.height;
                const maskCtx = maskCanvas.getContext('2d');

                // Draw the segmentation mask
                maskCtx.drawImage(
                    segmentationResult.segmentationMask,
                    0, 0,
                    backgroundImageOriginal.width,
                    backgroundImageOriginal.height
                );

                // Clean up the mask
                const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                const maskData = maskImageData.data;
                const width = maskCanvas.width;
                const height = maskCanvas.height;

                // Use user outline if available, otherwise use detected subject
                const subjectBox = userOutline || detectedSubject;
                if (subjectBox) {
                    // Expand bounding box by 20% to include edges
                    const padding = 0.2;
                    const boxX = Math.max(0, subjectBox.x - subjectBox.width * padding);
                    const boxY = Math.max(0, subjectBox.y - subjectBox.height * padding);
                    const boxW = Math.min(width - boxX, subjectBox.width * (1 + padding * 2));
                    const boxH = Math.min(height - boxY, subjectBox.height * (1 + padding * 2));
                    const boxRight = boxX + boxW;
                    const boxBottom = boxY + boxH;

                    // Remove mask pixels outside the bounding box
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            if (x < boxX || x > boxRight || y < boxY || y > boxBottom) {
                                const idx = (y * width + x) * 4;
                                maskData[idx] = 0;
                                maskData[idx + 1] = 0;
                                maskData[idx + 2] = 0;
                                maskData[idx + 3] = 0;
                            }
                        }
                    }
                }

                // Apply threshold to remove faint/semi-transparent areas
                for (let i = 0; i < maskData.length; i += 4) {
                    if (maskData[i] < maskThreshold) {
                        maskData[i] = 0;
                        maskData[i + 1] = 0;
                        maskData[i + 2] = 0;
                        maskData[i + 3] = 0;
                    }
                }
                maskCtx.putImageData(maskImageData, 0, 0);

                // Apply edge expansion/contraction if set
                if (maskExpand !== 0) {
                    const expandData = maskCtx.getImageData(0, 0, width, height);
                    const srcData = new Uint8ClampedArray(expandData.data);
                    const radius = Math.abs(maskExpand);
                    const expanding = maskExpand > 0;

                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = (y * width + x) * 4;
                            let hasNeighbor = false;

                            // Check neighbors within radius
                            for (let dy = -radius; dy <= radius && !hasNeighbor; dy++) {
                                for (let dx = -radius; dx <= radius && !hasNeighbor; dx++) {
                                    const ny = y + dy, nx = x + dx;
                                    if (ny >= 0 && ny < height && nx >= 0 && nx < width) {
                                        const nidx = (ny * width + nx) * 4;
                                        if (srcData[nidx] > 128) hasNeighbor = true;
                                    }
                                }
                            }

                            if (expanding) {
                                // Expand: if any neighbor is white, make this white
                                if (hasNeighbor) {
                                    expandData.data[idx] = expandData.data[idx + 1] = expandData.data[idx + 2] = expandData.data[idx + 3] = 255;
                                }
                            } else {
                                // Contract: if current is white but on edge (not all neighbors white), make transparent
                                if (srcData[idx] > 128 && !hasNeighbor) {
                                    expandData.data[idx] = expandData.data[idx + 1] = expandData.data[idx + 2] = expandData.data[idx + 3] = 0;
                                }
                            }
                        }
                    }
                    maskCtx.putImageData(expandData, 0, 0);
                }

                // Apply feathering (blur) if set
                if (maskFeather > 0) {
                    const featherCanvas = document.createElement('canvas');
                    featherCanvas.width = width;
                    featherCanvas.height = height;
                    const featherCtx = featherCanvas.getContext('2d');
                    featherCtx.filter = `blur(${maskFeather}px)`;
                    featherCtx.drawImage(maskCanvas, 0, 0);
                    maskCtx.clearRect(0, 0, width, height);
                    maskCtx.drawImage(featherCanvas, 0, 0);
                }

                // Create final image with transparent background
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = backgroundImageOriginal.width;
                finalCanvas.height = backgroundImageOriginal.height;
                const finalCtx = finalCanvas.getContext('2d');

                // Draw original image
                finalCtx.drawImage(backgroundImageOriginal, 0, 0);

                // Apply mask - keep only the person (where mask is white)
                finalCtx.globalCompositeOperation = 'destination-in';
                finalCtx.drawImage(maskCanvas, 0, 0);
                finalCtx.globalCompositeOperation = 'source-over';

                // Convert to image
                const resultUrl = finalCanvas.toDataURL('image/png');
                backgroundImageRemoved = new Image();
                backgroundImageRemoved.onload = () => {
                    statusEl.textContent = 'Background removed';
                    statusEl.className = 'model-status ready';
                    isProcessingBg = false;
                    drawBackgroundWithSubject();
                };
                backgroundImageRemoved.src = resultUrl;

            } catch (err) {
                console.error('Background removal failed:', err);
                statusEl.textContent = 'Removal failed: ' + err.message;
                statusEl.className = 'model-status';
                isProcessingBg = false;
                // Fall back to normal mode
                bgMode = 'normal';
                updateBgModeButtons();
                drawBackgroundWithSubject();
            }
        }

        document.getElementById('bgModeNormal').addEventListener('click', () => {
            bgMode = 'normal';
            updateBgModeButtons();
            document.getElementById('bgEffectStatus').textContent = '';
            if (backgroundImage) drawBackgroundWithSubject();
        });

        document.getElementById('bgModeBlur').addEventListener('click', () => {
            bgMode = 'blur';
            updateBgModeButtons();
            document.getElementById('bgEffectStatus').textContent = '';
            if (backgroundImage) drawBackgroundWithSubject();
        });

        document.getElementById('bgModeFade').addEventListener('click', () => {
            bgMode = 'fade';
            updateBgModeButtons();
            document.getElementById('bgEffectStatus').textContent = '';
            if (backgroundImage) drawBackgroundWithSubject();
        });

        document.getElementById('bgModeRemove').addEventListener('click', () => {
            bgMode = 'remove';
            updateBgModeButtons();
            if (backgroundImage) {
                processBackgroundRemoval();
            }
        });

        // Initialize bg mode buttons
        updateBgModeButtons();

        // =====================================================================
        // BACKGROUND REMOVAL CONTROLS
        // =====================================================================

        // Threshold slider
        document.getElementById('maskThreshold').addEventListener('input', (e) => {
            maskThreshold = parseInt(e.target.value);
            document.getElementById('thresholdValue').textContent = maskThreshold;
        });

        // Edge expand/contract slider
        document.getElementById('maskExpand').addEventListener('input', (e) => {
            maskExpand = parseInt(e.target.value);
            document.getElementById('expandValue').textContent = maskExpand;
        });

        // Feather slider
        document.getElementById('maskFeather').addEventListener('input', (e) => {
            maskFeather = parseInt(e.target.value);
            document.getElementById('featherValue').textContent = maskFeather;
        });

        // Reprocess button
        document.getElementById('reprocessBtn').addEventListener('click', () => {
            backgroundImageRemoved = null;  // Clear cached result
            processBackgroundRemoval();
        });

        // Draw outline button
        let drawingOutline = false;
        let outlinePoints = [];

        document.getElementById('drawOutlineBtn').addEventListener('click', () => {
            drawingOutline = !drawingOutline;
            const btn = document.getElementById('drawOutlineBtn');
            const clearBtn = document.getElementById('clearOutlineBtn');
            if (drawingOutline) {
                btn.style.background = '#d4a44a';
                btn.style.color = '#1a1a2e';
                btn.textContent = 'Finish Outline';
                outlinePoints = [];
                // Clear any existing outline from effect canvas
                const effectCtx = effectCanvas.getContext('2d');
                effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
                alert('Draw a rough outline around the subject you want to keep. Click "Finish Outline" when done.');
            } else {
                btn.style.background = '#444';
                btn.style.color = '#fff';
                btn.textContent = 'Draw Outline';
                if (outlinePoints.length > 2) {
                    // Create bounding box from outline
                    const xs = outlinePoints.map(p => p.x);
                    const ys = outlinePoints.map(p => p.y);
                    userOutline = {
                        x: Math.min(...xs),
                        y: Math.min(...ys),
                        width: Math.max(...xs) - Math.min(...xs),
                        height: Math.max(...ys) - Math.min(...ys)
                    };
                    // Show clear button since we have an outline
                    clearBtn.style.display = 'inline-block';
                    // Reprocess with user outline
                    backgroundImageRemoved = null;
                    processBackgroundRemoval();
                }
            }
        });

        // Clear outline button
        document.getElementById('clearOutlineBtn').addEventListener('click', () => {
            userOutline = null;
            outlinePoints = [];
            document.getElementById('clearOutlineBtn').style.display = 'none';
            // Clear effect canvas
            const effectCtx = effectCanvas.getContext('2d');
            effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
            // Reprocess without user outline (use auto-detection)
            backgroundImageRemoved = null;
            processBackgroundRemoval();
        });

        // Cleanup brush button
        document.getElementById('cleanupBrushBtn').addEventListener('click', () => {
            document.getElementById('cleanupControls').style.display = 'flex';
            cleanupMode = 'erase';
            updateCleanupButtons();
        });

        // Cleanup mode buttons
        document.getElementById('brushErase').addEventListener('click', () => {
            cleanupMode = 'erase';
            updateCleanupButtons();
        });

        document.getElementById('brushRestore').addEventListener('click', () => {
            cleanupMode = 'restore';
            updateCleanupButtons();
        });

        function updateCleanupButtons() {
            const eraseBtn = document.getElementById('brushErase');
            const restoreBtn = document.getElementById('brushRestore');
            if (cleanupMode === 'erase') {
                eraseBtn.style.background = '#a33';
                restoreBtn.style.background = '#444';
            } else {
                eraseBtn.style.background = '#444';
                restoreBtn.style.background = '#3a3';
            }
        }

        // Brush size slider
        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        // Done cleanup button
        document.getElementById('doneCleanupBtn').addEventListener('click', () => {
            document.getElementById('cleanupControls').style.display = 'none';
            cleanupMode = null;
        });

        // =====================================================================
        // DRAWING STATE
        // =====================================================================
        let isDrawing = false;
        let currentStroke = [];
        let allStrokes = [];
        let lastPoint = null;
        let lastTime = 0;
        let lastWidth = config.minWidth;
        let isPenDetected = false;

        // Smoothing state
        let smoothX = 0, smoothY = 0;
        let smoothPressure = 0;

        // Stabilizer state
        let stabilizerX = 0, stabilizerY = 0;

        // Metallic animation state
        let metallicOffset = 0;
        let animationId = null;
        let isCanvasFilled = false;
        let isPaused = false;
        let animationDirection = 1;  // 1 = right, -1 = left
        let animationSpeed = 2;      // pixels per frame

        // Recording state - always recording
        let recordedEvents = [];     // Stores {type, data, time} events
        let recordingStartTime = 0;
        let isPlayingRecording = false;
        let hasStartedRecording = false;  // Track if we've started timing

        // =====================================================================
        // METALLIC GRADIENT ANIMATION - Shiny gold effect
        // =====================================================================
        function startMetallicAnimation() {
            if (animationId) return;

            function animate() {
                metallicOffset += animationSpeed * animationDirection;
                // Wrap around in both directions
                if (metallicOffset > patternWidth) {
                    metallicOffset = 0;
                } else if (metallicOffset < 0) {
                    metallicOffset = patternWidth;
                }
                updateMetallicMask();
                animationId = requestAnimationFrame(animate);
            }
            animate();
        }

        function stopMetallicAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function updateMetallicMask() {
            // Clear effect canvas
            effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            if (allStrokes.length === 0) {
                return;
            }

            // Calculate bounding box of strokes
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const stroke of allStrokes) {
                for (const pt of stroke) {
                    minX = Math.min(minX, pt.x);
                    minY = Math.min(minY, pt.y);
                    maxX = Math.max(maxX, pt.x);
                    maxY = Math.max(maxY, pt.y);
                }
            }

            const centerY = (minY + maxY) / 2;
            const width = maxX - minX;
            const height = maxY - minY;

            // Moving spotlight center - travels left to right across the text
            const spotX = minX - 100 + (metallicOffset % (width + 400));
            const spotRadius = Math.max(width, height) * 0.6;

            // Create radial gradient - soft glowing spotlight (like reference_gradient.png)
            const gradient = effectCtx.createRadialGradient(
                spotX, centerY, 0,
                spotX, centerY, spotRadius
            );

            // Soft glow: bright cream center fading to orange (like the reference)
            gradient.addColorStop(0, '#FFFEF0');     // Bright cream/white center
            gradient.addColorStop(0.2, '#FFE4A0');   // Light gold
            gradient.addColorStop(0.4, '#FFD700');   // Gold
            gradient.addColorStop(0.6, '#FFA500');   // Orange
            gradient.addColorStop(0.8, '#E07800');   // Darker orange
            gradient.addColorStop(1, '#CC6600');     // Dark orange edge

            // Step 1: Copy the white strokes from drawCanvas to effectCanvas
            effectCtx.drawImage(drawCanvas, 0, 0, canvasWidth, canvasHeight);

            // Step 2: Use source-in to replace white with glowing gradient
            effectCtx.globalCompositeOperation = 'source-in';
            effectCtx.fillStyle = gradient;
            effectCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            effectCtx.globalCompositeOperation = 'source-over';
        }

        // Alias for backward compatibility
        function updateRadialGlow() {
            updateMetallicMask();
        }

        function updateGradientMask() {
            updateMetallicMask();
        }

        // =====================================================================
        // INPUT HANDLING
        // =====================================================================
        function getPointerData(e) {
            const rect = drawCanvas.getBoundingClientRect();

            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            return {
                x: x,
                y: y,
                pressure: e.pressure || 0.5,
                tiltX: e.tiltX || 0,
                tiltY: e.tiltY || 0,
                pointerType: e.pointerType || 'mouse',
                time: performance.now(),
                isPen: e.pointerType === 'pen',
            };
        }

        function calculateWidth(pointerData, velocity) {
            let width = (config.minWidth + config.maxWidth) / 2;

            // Pressure-based width
            if (config.pressureEnabled && pointerData.isPen) {
                let adjustedPressure = Math.pow(pointerData.pressure, config.pressureCurve);
                adjustedPressure = Math.min(1, adjustedPressure * config.pressureMultiplier);
                width = config.minWidth + (config.maxWidth - config.minWidth) * adjustedPressure;
            }

            // Velocity adjustment
            if (config.velocityEnabled && velocity > 0) {
                const velocityFactor = Math.max(0.3, 1 - velocity * config.velocityFactor * 0.01);
                width *= velocityFactor;
            }

            // Direction-based width (calligraphy)
            if (config.directionWidthEnabled && pointerData.direction !== undefined) {
                const dir = pointerData.direction;
                if (dir.y > 0.2) {
                    const downAmount = (dir.y - 0.2) / 0.8;
                    const directionMultiplier = config.directionWidthMin +
                        (1 - config.directionWidthMin) * downAmount;
                    width *= directionMultiplier;
                } else {
                    width *= config.directionWidthMin;
                }
            }

            return Math.max(config.minWidth, Math.min(config.maxWidth, width));
        }

        // =====================================================================
        // DRAWING FUNCTIONS
        // =====================================================================
        function startStroke(e) {
            if (isPlayingRecording) return;  // Don't allow drawing during playback

            // Block handwriting when in background removal modes
            if (drawingOutline || cleanupMode) {
                e.preventDefault();
                if (drawingOutline) {
                    // Handle outline drawing - use screen coordinates (context already has DPR scale)
                    const rect = effectCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    outlinePoints.push({x, y});
                    const effectCtx = effectCanvas.getContext('2d');
                    effectCtx.strokeStyle = '#ff0';
                    effectCtx.lineWidth = 3;
                    if (outlinePoints.length === 1) {
                        effectCtx.beginPath();
                        effectCtx.arc(x, y, 5, 0, Math.PI * 2);
                        effectCtx.stroke();
                    } else {
                        effectCtx.beginPath();
                        effectCtx.moveTo(outlinePoints[outlinePoints.length - 2].x, outlinePoints[outlinePoints.length - 2].y);
                        effectCtx.lineTo(x, y);
                        effectCtx.stroke();
                    }
                } else if (cleanupMode && backgroundImageRemoved) {
                    // Handle cleanup brush
                    isCleaningUp = true;
                    applyCleanupBrush(e);
                }
                return;  // Block all normal drawing
            }

            if (config.palmRejection && e.pointerType === 'touch' && isPenDetected) {
                return;
            }

            e.preventDefault();

            // Handle outline drawing mode (legacy check - now handled above)
            if (drawingOutline) {
                const rect = drawCanvas.getBoundingClientRect();
                const scaleX = drawCanvas.width / rect.width;
                const scaleY = drawCanvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                outlinePoints.push({x, y});

                // Draw visual feedback on effect canvas
                const effectCtx = effectCanvas.getContext('2d');
                effectCtx.strokeStyle = '#ff0';
                effectCtx.lineWidth = 3;
                if (outlinePoints.length === 1) {
                    effectCtx.beginPath();
                    effectCtx.arc(x, y, 5, 0, Math.PI * 2);
                    effectCtx.stroke();
                } else {
                    effectCtx.beginPath();
                    effectCtx.moveTo(outlinePoints[outlinePoints.length - 2].x, outlinePoints[outlinePoints.length - 2].y);
                    effectCtx.lineTo(x, y);
                    effectCtx.stroke();
                }
                return;
            }

            // Handle cleanup brush mode
            if (cleanupMode && backgroundImageRemoved) {
                isCleaningUp = true;
                applyCleanupBrush(e);
                return;
            }

            isDrawing = true;

            const data = getPointerData(e);

            // Always record - start timing on first stroke
            if (!hasStartedRecording) {
                recordingStartTime = performance.now();
                hasStartedRecording = true;
            }
            recordedEvents.push({
                type: 'start',
                data: {...data},
                time: performance.now() - recordingStartTime
            });

            if (data.isPen) {
                isPenDetected = true;
                document.getElementById('pencilStatus').textContent = 'Pencil Active';
                document.getElementById('pencilStatus').classList.add('active');
            }

            smoothX = data.x;
            smoothY = data.y;
            smoothPressure = data.pressure;
            stabilizerX = data.x;
            stabilizerY = data.y;

            // Start animation immediately
            if (!animationId) {
                startMetallicAnimation();
            }

            currentStroke = [data];
            lastPoint = data;
            lastTime = data.time;
            lastWidth = calculateWidth(data, 0);
        }

        function continueStroke(e) {
            // Block handwriting when in background removal modes
            if (drawingOutline || cleanupMode) {
                e.preventDefault();
                if (drawingOutline && outlinePoints.length > 0) {
                    // Use screen coordinates (context already has DPR scale)
                    const rect = effectCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    outlinePoints.push({x, y});
                    const effectCtx = effectCanvas.getContext('2d');
                    effectCtx.strokeStyle = '#ff0';
                    effectCtx.lineWidth = 3;
                    effectCtx.beginPath();
                    effectCtx.moveTo(outlinePoints[outlinePoints.length - 2].x, outlinePoints[outlinePoints.length - 2].y);
                    effectCtx.lineTo(x, y);
                    effectCtx.stroke();
                } else if (isCleaningUp && cleanupMode) {
                    applyCleanupBrush(e);
                }
                return;  // Block all normal drawing
            }

            if (!isDrawing) return;

            if (config.palmRejection && e.pointerType === 'touch' && isPenDetected) {
                return;
            }

            e.preventDefault();

            const data = getPointerData(e);

            // Always record
            recordedEvents.push({
                type: 'move',
                data: {...data},
                time: performance.now() - recordingStartTime
            });

            // Apply stabilizer
            if (config.stabilizerEnabled && config.stabilizerStrength > 0) {
                const strength = config.stabilizerStrength;
                stabilizerX = stabilizerX + (data.x - stabilizerX) * (1 - strength);
                stabilizerY = stabilizerY + (data.y - stabilizerY) * (1 - strength);
                data.x = stabilizerX;
                data.y = stabilizerY;
            }

            // Apply smoothing
            if (config.smoothingEnabled) {
                smoothX += (data.x - smoothX) * config.smoothingFactor;
                smoothY += (data.y - smoothY) * config.smoothingFactor;
                smoothPressure += (data.pressure - smoothPressure) * config.smoothingFactor;
                data.x = smoothX;
                data.y = smoothY;
                data.pressure = smoothPressure;
            }

            // Calculate velocity and direction
            const dx = data.x - lastPoint.x;
            const dy = data.y - lastPoint.y;
            const dt = Math.max(1, data.time - lastTime);
            const distance = Math.sqrt(dx * dx + dy * dy);
            const velocity = distance / dt * 10;

            if (distance > 0.5) {
                data.direction = { x: dx / distance, y: dy / distance };
            } else {
                data.direction = lastPoint.direction || { x: 0, y: 1 };
            }

            const targetWidth = calculateWidth(data, velocity);
            const width = lastWidth * 0.85 + targetWidth * 0.15;
            data.width = width;

            // Draw on all layers
            drawSegment(lastPoint, data, lastWidth, width);

            currentStroke.push(data);
            lastPoint = data;
            lastTime = data.time;
            lastWidth = width;
        }

        function endStroke(e) {
            // Block handwriting when in background removal modes
            if (drawingOutline || cleanupMode) {
                if (isCleaningUp) {
                    isCleaningUp = false;
                }
                return;  // Block all normal drawing
            }

            if (!isDrawing) return;
            isDrawing = false;

            // Always record
            recordedEvents.push({
                type: 'end',
                data: {},
                time: performance.now() - recordingStartTime
            });

            if (currentStroke.length > 0) {
                allStrokes.push([...currentStroke]);
                // Start metallic animation
                if (!animationId) {
                    startMetallicAnimation();
                }
            }

            currentStroke = [];
            lastPoint = null;
        }

        function drawSegment(from, to, fromWidth, toWidth) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const len = Math.sqrt(dx * dx + dy * dy);

            if (len < 0.5) return;

            // Calculate chisel width
            let width = (fromWidth + toWidth) / 2;

            if (config.chiselMode) {
                const chiselAngle = config.chiselAngle * Math.PI / 180;
                const strokeAngle = Math.atan2(dy, dx);
                let angleDiff = Math.abs(strokeAngle - chiselAngle);
                while (angleDiff > Math.PI) angleDiff -= Math.PI;
                if (angleDiff > Math.PI / 2) angleDiff = Math.PI - angleDiff;

                const widthFactor = Math.abs(Math.sin(angleDiff * 2));
                const minFactor = 1 / config.chiselRatio;
                const actualFactor = minFactor + (1 - minFactor) * widthFactor;
                width *= actualFactor;
            }

            // Draw double stroke (darker, offset behind main)
            if (config.doubleStrokeEnabled) {
                const offset = config.doubleStrokeOffset;
                doubleCtx.beginPath();
                doubleCtx.moveTo(from.x + offset, from.y + offset);
                doubleCtx.lineTo(to.x + offset, to.y + offset);
                doubleCtx.lineWidth = Math.max(1, width);
                doubleCtx.strokeStyle = config.doubleStrokeColor;
                doubleCtx.lineCap = config.chiselMode ? 'square' : 'round';
                doubleCtx.lineJoin = config.chiselMode ? 'miter' : 'round';
                doubleCtx.stroke();
            }

            // Draw main stroke (solid orange/gold)
            drawCtx.beginPath();
            drawCtx.moveTo(from.x, from.y);
            drawCtx.lineTo(to.x, to.y);
            drawCtx.lineWidth = Math.max(1, width);
            drawCtx.strokeStyle = config.strokeColor;
            drawCtx.lineCap = config.chiselMode ? 'square' : 'round';
            drawCtx.lineJoin = config.chiselMode ? 'miter' : 'round';
            drawCtx.stroke();
        }

        function redrawAllStrokes() {
            // Clear all drawing layers
            glowCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            doubleCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Redraw all strokes
            for (const stroke of allStrokes) {
                for (let i = 1; i < stroke.length; i++) {
                    const from = stroke[i - 1];
                    const to = stroke[i];
                    const fromWidth = from.width || config.minWidth;
                    const toWidth = to.width || config.minWidth;
                    drawSegment(from, to, fromWidth, toWidth);
                }
            }
        }

        // =====================================================================
        // EVENT LISTENERS
        // =====================================================================
        drawCanvas.addEventListener('pointerdown', startStroke);
        drawCanvas.addEventListener('pointermove', continueStroke);
        drawCanvas.addEventListener('pointerup', endStroke);
        drawCanvas.addEventListener('pointercancel', endStroke);
        drawCanvas.addEventListener('pointerleave', endStroke);

        drawCanvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
        drawCanvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

        // =====================================================================
        // UI CONTROLS
        // =====================================================================
        document.getElementById('clearBtn').addEventListener('click', () => {
            stopMetallicAnimation();
            glowCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            doubleCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            allStrokes = [];
            currentStroke = [];
            // Reset recording
            recordedEvents = [];
            hasStartedRecording = false;
        });

        document.getElementById('undoBtn').addEventListener('click', () => {
            if (allStrokes.length === 0) return;
            allStrokes.pop();
            redrawAllStrokes();
            if (allStrokes.length === 0) {
                stopMetallicAnimation();
            }
        });

        // Fill Canvas button - fills the entire canvas to preview gradient
        document.getElementById('fillBtn').addEventListener('click', () => {
            if (isCanvasFilled) {
                // Clear the fill
                drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                allStrokes = [];
                isCanvasFilled = false;
                document.getElementById('fillBtn').textContent = 'Fill Canvas';
                if (!isPaused) {
                    stopMetallicAnimation();
                }
                effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            } else {
                // Fill the canvas with white (solid rectangle)
                drawCtx.fillStyle = '#FFFFFF';
                drawCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                isCanvasFilled = true;
                document.getElementById('fillBtn').textContent = 'Clear Fill';
                // Start animation to show the gradient
                if (!isPaused && !animationId) {
                    startMetallicAnimation();
                } else {
                    // If paused, just show current frame
                    updateMetallicMask();
                }
            }
        });

        // Play/Pause button for gradient animation
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            if (isPaused) {
                // Resume
                isPaused = false;
                document.getElementById('playPauseBtn').textContent = 'Pause';
                if (allStrokes.length > 0 || isCanvasFilled) {
                    startMetallicAnimation();
                }
            } else {
                // Pause
                isPaused = true;
                document.getElementById('playPauseBtn').textContent = 'Play';
                stopMetallicAnimation();
                // Keep the current frame visible
                updateMetallicMask();
            }
        });

        // Direction toggle
        document.getElementById('directionBtn').addEventListener('click', () => {
            animationDirection *= -1;
            const btn = document.getElementById('directionBtn');
            btn.textContent = animationDirection === 1 ? 'â†’ Right' : 'â† Left';
        });

        // Speed slider
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed;
        });

        // Replay button - plays back recorded strokes with original timing
        document.getElementById('playRecordingBtn').addEventListener('click', () => {
            if (recordedEvents.length === 0) {
                alert('Nothing to replay. Draw something first!');
                return;
            }
            if (isPlayingRecording) return;

            // Clear canvas before playback
            stopMetallicAnimation();
            glowCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            doubleCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            allStrokes = [];
            currentStroke = [];

            isPlayingRecording = true;
            const btn = document.getElementById('playRecordingBtn');
            btn.textContent = 'Playing...';
            btn.disabled = true;

            // Play back each event at the recorded time (preserves pauses)
            const playbackStart = performance.now();
            let eventIndex = 0;

            function playNextEvent() {
                if (eventIndex >= recordedEvents.length) {
                    // Playback complete
                    isPlayingRecording = false;
                    btn.textContent = 'Replay';
                    btn.disabled = false;
                    return;
                }

                const elapsed = performance.now() - playbackStart;

                // Process ALL events that should have happened by now
                while (eventIndex < recordedEvents.length && recordedEvents[eventIndex].time <= elapsed) {
                    const event = recordedEvents[eventIndex];
                    const data = {...event.data};  // Clone to avoid modifying original

                    if (event.type === 'start') {
                        // Simulate stroke start
                        isDrawing = true;
                        smoothX = data.x;
                        smoothY = data.y;
                        smoothPressure = data.pressure;
                        stabilizerX = data.x;
                        stabilizerY = data.y;
                        if (!animationId) startMetallicAnimation();
                        currentStroke = [data];
                        lastPoint = data;
                        lastTime = data.time;
                        lastWidth = calculateWidth(data, 0);
                    } else if (event.type === 'move' && isDrawing) {
                        // Apply stabilizer
                        if (config.stabilizerEnabled && config.stabilizerStrength > 0) {
                            const strength = config.stabilizerStrength;
                            stabilizerX = stabilizerX + (data.x - stabilizerX) * (1 - strength);
                            stabilizerY = stabilizerY + (data.y - stabilizerY) * (1 - strength);
                            data.x = stabilizerX;
                            data.y = stabilizerY;
                        }
                        // Apply smoothing
                        if (config.smoothingEnabled) {
                            smoothX += (data.x - smoothX) * config.smoothingFactor;
                            smoothY += (data.y - smoothY) * config.smoothingFactor;
                            smoothPressure += (data.pressure - smoothPressure) * config.smoothingFactor;
                            data.x = smoothX;
                            data.y = smoothY;
                            data.pressure = smoothPressure;
                        }
                        // Calculate velocity and direction
                        const dx = data.x - lastPoint.x;
                        const dy = data.y - lastPoint.y;
                        const dt = Math.max(1, data.time - lastTime);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const velocity = distance / dt * 10;
                        if (distance > 0.5) {
                            data.direction = { x: dx / distance, y: dy / distance };
                        } else {
                            data.direction = lastPoint.direction || { x: 0, y: 1 };
                        }
                        const targetWidth = calculateWidth(data, velocity);
                        const width = lastWidth * 0.85 + targetWidth * 0.15;
                        data.width = width;
                        drawSegment(lastPoint, data, lastWidth, width);
                        currentStroke.push(data);
                        lastPoint = data;
                        lastTime = data.time;
                        lastWidth = width;
                    } else if (event.type === 'end') {
                        isDrawing = false;
                        if (currentStroke.length > 0) {
                            allStrokes.push([...currentStroke]);
                        }
                        currentStroke = [];
                        lastPoint = null;
                    }

                    eventIndex++;
                }

                requestAnimationFrame(playNextEvent);
            }

            playNextEvent();
        });

        // =====================================================================
        // PATTERN DESIGNER CANVAS
        // =====================================================================
        const patternCanvas = document.getElementById('patternCanvas');
        const patternCtx = patternCanvas.getContext('2d');
        const patternContainer = document.getElementById('patternContainer');
        let patternWidth = 800;
        let patternHeight = 120;
        let isPatternDrawing = false;

        function setupPatternCanvas() {
            const dpr = window.devicePixelRatio || 1;

            // Match the main canvas dimensions
            patternWidth = canvasWidth || 800;
            patternHeight = canvasHeight || 480;

            patternCanvas.width = patternWidth * dpr;
            patternCanvas.height = patternHeight * dpr;
            patternCanvas.style.width = patternWidth + 'px';
            patternCanvas.style.height = patternHeight + 'px';

            // Update container to match
            const container = document.getElementById('patternContainer');
            if (container) {
                container.style.width = patternWidth + 'px';
                container.style.height = patternHeight + 'px';
            }

            // Also update the pattern-designer wrapper
            const designer = document.querySelector('.pattern-designer');
            if (designer) {
                designer.style.width = patternWidth + 'px';
            }

            patternCtx.setTransform(1, 0, 0, 1, 0, 0);
            patternCtx.scale(dpr, dpr);

            resetPatternToGold();
        }

        function resetPatternToGold() {
            // Solid light copper/bronze
            patternCtx.fillStyle = '#CD7F32';  // Light bronze/copper
            patternCtx.fillRect(0, 0, patternWidth, patternHeight);
        }

        function paintOnPattern(e) {
            const rect = patternCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const brushSize = parseInt(document.getElementById('patternBrushSize').value);

            // Round brush with smooth yellow cream gradient
            const gradient = patternCtx.createRadialGradient(x, y, 0, x, y, brushSize);
            gradient.addColorStop(0, 'rgba(255, 245, 180, 0.5)');     // Yellow cream center
            gradient.addColorStop(0.05, 'rgba(255, 243, 175, 0.45)');
            gradient.addColorStop(0.1, 'rgba(255, 240, 170, 0.4)');
            gradient.addColorStop(0.15, 'rgba(255, 238, 165, 0.35)');
            gradient.addColorStop(0.2, 'rgba(255, 235, 160, 0.3)');
            gradient.addColorStop(0.25, 'rgba(255, 232, 155, 0.25)');
            gradient.addColorStop(0.3, 'rgba(255, 230, 150, 0.2)');
            gradient.addColorStop(0.4, 'rgba(255, 225, 145, 0.15)');
            gradient.addColorStop(0.5, 'rgba(255, 220, 140, 0.1)');
            gradient.addColorStop(0.6, 'rgba(255, 215, 135, 0.07)');
            gradient.addColorStop(0.7, 'rgba(255, 210, 130, 0.04)');
            gradient.addColorStop(0.8, 'rgba(255, 205, 125, 0.02)');
            gradient.addColorStop(0.9, 'rgba(255, 200, 120, 0.01)');
            gradient.addColorStop(1, 'rgba(255, 195, 115, 0)');

            patternCtx.fillStyle = gradient;
            patternCtx.beginPath();
            patternCtx.arc(x, y, brushSize, 0, Math.PI * 2);
            patternCtx.fill();
        }

        // Pattern canvas events
        patternCanvas.addEventListener('pointerdown', (e) => {
            isPatternDrawing = true;
            paintOnPattern(e);
        });

        patternCanvas.addEventListener('pointermove', (e) => {
            if (isPatternDrawing) {
                paintOnPattern(e);
            }
        });

        patternCanvas.addEventListener('pointerup', () => {
            isPatternDrawing = false;
        });

        patternCanvas.addEventListener('pointerleave', () => {
            isPatternDrawing = false;
        });

        document.getElementById('resetPatternBtn').addEventListener('click', resetPatternToGold);

        // Initialize pattern canvas
        setupPatternCanvas();
        window.addEventListener('resize', setupPatternCanvas);

        // =====================================================================
        // UPDATE METALLIC MASK TO USE PATTERN CANVAS
        // =====================================================================
        // Override the updateMetallicMask to use the pattern canvas
        const originalUpdateMetallicMask = updateMetallicMask;
        updateMetallicMask = function() {
            // Check if there's anything to render (completed strokes, active drawing, or filled canvas)
            const hasContent = allStrokes.length > 0 || currentStroke.length > 0 || isCanvasFilled;
            if (!hasContent) {
                effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                return;
            }

            // Calculate offset for scrolling pattern
            const patternOffset = metallicOffset % patternWidth;

            // Clear effect canvas
            effectCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Step 1: Draw the pattern first (this will be the visible result)
            for (let x = -patternOffset; x < canvasWidth + patternWidth; x += patternWidth) {
                effectCtx.drawImage(patternCanvas,
                    0, 0, patternCanvas.width, patternCanvas.height,
                    x, 0, patternWidth, canvasHeight);
            }

            // Step 2: Apply mask using destination-in
            // Pattern (destination) will only show where mask (source) is non-transparent
            effectCtx.globalCompositeOperation = 'destination-in';

            if (isCanvasFilled) {
                // Fill entire canvas - pattern shows everywhere
                effectCtx.fillStyle = '#FFFFFF';
                effectCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            } else {
                // Copy strokes from drawCanvas as the mask
                effectCtx.drawImage(drawCanvas,
                    0, 0, drawCanvas.width, drawCanvas.height,
                    0, 0, canvasWidth, canvasHeight);
            }

            effectCtx.globalCompositeOperation = 'source-over';
        };

        // =====================================================================
        // INITIALIZATION
        // =====================================================================
        if (window.PointerEvent) {
            console.log('Golden Ink - Apple Pencil ready');
        }

        // Load the AI model for subject detection
        loadModel();
    </script>
</body>
</html>
